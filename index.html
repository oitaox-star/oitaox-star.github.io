<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>WebAR + Bottom UI (Toggle)</title>

  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <!-- AR.js -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <!-- Gesture detector -->
  <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-gesture-detector-component@master/dist/aframe-gesture-detector-component.min.js"></script>

  <style>
    body{margin:0; overflow:hidden; font-family:system-ui, -apple-system, "Noto Sans JP", sans-serif;}

    /* ローディング */
    .loader{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:#000c; color:#fff; z-index:9998;
      font-size:14px;
    }

    /* UIトグルボタン（右下） */
    .ui-toggle{
      position:fixed; right:10px; bottom:10px;
      z-index:10000;
      border:1px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.45);
      color:#fff;
      border-radius: 999px;
      padding: 10px 12px;
      font-size:12px;
      backdrop-filter: blur(8px);
      cursor:pointer;
      user-select:none;
    }
    .ui-toggle:active{transform: translateY(1px);}

    /* 下部UI（コンパクト） */
    .ui {
      position: fixed; left: 10px; right: 10px; bottom: 60px;
      z-index: 9999;
      max-width: 520px; /* PCでも広がりすぎない */
      margin: 0 auto;

      background: rgba(0,0,0,.55);
      color: #fff;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 16px;
      padding: 10px 12px;
      backdrop-filter: blur(8px);
    }

    .ui.hidden{display:none;}

    .ui-head{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; margin-bottom:8px;
    }
    .ui h2{font-size:13px; margin:0; font-weight:700;}
    .badge{
      display:inline-block; font-size:11px; padding:2px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.22); background: rgba(255,255,255,.10);
    }

    .row{display:flex; gap:8px; align-items:center; margin:6px 0;}
    .row label{font-size:11px; opacity:.9; width:70px; flex:0 0 70px;}
    .row input[type="range"]{flex:1}

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px 10px;
    }
    @media (max-width: 420px){
      .grid{grid-template-columns: 1fr;}
    }

    .btns{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px;}
    button{
      appearance:none; border:1px solid rgba(255,255,255,.22);
      background: rgba(255,255,255,.10);
      color:#fff; border-radius: 12px;
      padding: 8px 10px; font-size:12px; cursor:pointer;
    }
    button:active{transform: translateY(1px);}
    select{
      width:100%; padding:8px 10px; border-radius: 12px;
      border:1px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.25); color:#fff;
      outline:none;
    }
    .hint{font-size:11px; opacity:.8; line-height:1.35; margin-top:6px;}
  </style>

  <script>
    // タッチ操作：ドラッグ回転 / ピンチ拡大縮小
    AFRAME.registerComponent('gesture-handler', {
      schema: {
        minScale: { default: 0.3 },
        maxScale: { default: 3.0 },
        rotSpeed: { default: 0.01 },
        scaleSpeed: { default: 0.005 }
      },
      init: function () {
        const el = this.el;
        this.state = {
          rotX: el.object3D.rotation.x,
          rotY: el.object3D.rotation.y,
          scale: el.object3D.scale.x || 1
        };
        this.onOneFingerMove = this.onOneFingerMove.bind(this);
        this.onTwoFingerMove = this.onTwoFingerMove.bind(this);
        el.sceneEl.addEventListener('onefingermove', this.onOneFingerMove);
        el.sceneEl.addEventListener('twofingermove', this.onTwoFingerMove);
      },
      remove: function () {
        this.el.sceneEl.removeEventListener('onefingermove', this.onOneFingerMove);
        this.el.sceneEl.removeEventListener('twofingermove', this.onTwoFingerMove);
      },
      onOneFingerMove: function (e) {
        if (!this.el.object3D.visible) return;
        const d = e.detail.positionChange;
        this.state.rotY += d.x * this.data.rotSpeed;
        this.state.rotX += d.y * this.data.rotSpeed;
        this.el.object3D.rotation.set(this.state.rotX, this.state.rotY, 0);
      },
      onTwoFingerMove: function (e) {
        if (!this.el.object3D.visible) return;
        const spreadChange = e.detail.spreadChange;
        this.state.scale += spreadChange * this.data.scaleSpeed;
        this.state.scale = Math.min(this.data.maxScale, Math.max(this.data.minScale, this.state.scale));
        this.el.object3D.scale.set(this.state.scale, this.state.scale, this.state.scale);
      }
    });

    // UIでモデルを制御（サイズ/回転/自動回転/アニメ）
    AFRAME.registerComponent('model-ui-controller', {
      init: function () {
        this.mixer = null;
        this.activeAction = null;
        this.clips = [];
        this.clock = new THREE.Clock();
        this.isPlaying = false;
        this.speed = 1.0;
        this.autoRotate = false;

        const obj = this.el.object3D;
        this.base = {
          scale: obj.scale.x || 1,
          rotX: obj.rotation.x,
          rotY: obj.rotation.y,
          rotZ: obj.rotation.z
        };

        this.ui = {
          root: document.getElementById('ui'),
          toggleBtn: document.getElementById('ui-toggle'),

          scale: document.getElementById('ui-scale'),
          rotY: document.getElementById('ui-roty'),
          rotX: document.getElementById('ui-rotx'),
          rotZ: document.getElementById('ui-rotz'),
          autoRotate: document.getElementById('ui-autorotate'),
          reset: document.getElementById('ui-reset'),

          animSelect: document.getElementById('ui-anim-select'),
          animPlay: document.getElementById('ui-anim-play'),
          animStop: document.getElementById('ui-anim-stop'),
          animSpeed: document.getElementById('ui-anim-speed'),
          animSpeedVal: document.getElementById('ui-anim-speed-val'),
          animStatus: document.getElementById('ui-anim-status'),
          animWrap: document.getElementById('ui-anim-wrap')
        };

        // UIタッチがAR操作に伝播しないようにする
        ['touchstart','touchmove','touchend','pointerdown','pointermove','pointerup'].forEach(ev=>{
          this.ui.root.addEventListener(ev, (e)=> e.stopPropagation(), {passive:false});
        });

        // UI表示/非表示（右下ボタン）
        this.ui.toggleBtn.addEventListener('click', () => {
          const hidden = this.ui.root.classList.toggle('hidden');
          this.ui.toggleBtn.textContent = hidden ? '操作UIを表示' : '操作UIを隠す';
        });

        // モデル読み込み
        this.el.addEventListener('model-loaded', (e) => {
          const mesh = e.detail.model;
          this._setupAnimations(mesh);
          this._syncUIFromModel();
          document.getElementById('loader').style.display = 'none';
        });

        this.el.addEventListener('model-error', (e) => {
          console.error('model-error', e);
          alert('model.glb の読み込みに失敗しました。assets/model.glb を確認してください。');
        });

        this._bindUI();
      },

      tick: function () {
        if (this.autoRotate && this.el.object3D.visible) {
          this.el.object3D.rotation.y += 0.01;
          this.ui.rotY.value = this.el.object3D.rotation.y.toFixed(3);
        }

        if (this.mixer && this.isPlaying && this.el.object3D.visible) {
          const dt = this.clock.getDelta();
          this.mixer.update(dt * this.speed);
        } else {
          this.clock.getDelta();
        }
      },

      _bindUI: function () {
        // Scale
        this.ui.scale.addEventListener('input', () => {
          const s = parseFloat(this.ui.scale.value);
          this.el.object3D.scale.set(s,s,s);
        });

        // Rotation
        this.ui.rotX.addEventListener('input', () => this.el.object3D.rotation.x = parseFloat(this.ui.rotX.value));
        this.ui.rotY.addEventListener('input', () => this.el.object3D.rotation.y = parseFloat(this.ui.rotY.value));
        this.ui.rotZ.addEventListener('input', () => this.el.object3D.rotation.z = parseFloat(this.ui.rotZ.value));

        // Auto rotate
        this.ui.autoRotate.addEventListener('change', () => {
          this.autoRotate = this.ui.autoRotate.checked;
        });

        // Reset
        this.ui.reset.addEventListener('click', () => {
          this.el.object3D.scale.set(this.base.scale, this.base.scale, this.base.scale);
          this.el.object3D.rotation.set(this.base.rotX, this.base.rotY, this.base.rotZ);
          this._syncUIFromModel();
        });

        // Animation select
        this.ui.animSelect.addEventListener('change', () => {
          const idx = parseInt(this.ui.animSelect.value, 10);
          this._playClipByIndex(idx, true);
        });

        // Play
        this.ui.animPlay.addEventListener('click', () => {
          if (!this.mixer || !this.activeAction) return;
          this.isPlaying = true;
          this.activeAction.paused = false;
          this.activeAction.play();
          this._setAnimStatus('再生中');
        });

        // Stop
        this.ui.animStop.addEventListener('click', () => {
          if (!this.mixer || !this.activeAction) return;
          this.isPlaying = false;
          this.activeAction.stop();
          this.mixer.setTime(0);
          this._setAnimStatus('停止');
        });

        // Speed
        this.ui.animSpeed.addEventListener('input', () => {
          this.speed = parseFloat(this.ui.animSpeed.value);
          this.ui.animSpeedVal.textContent = this.speed.toFixed(2) + 'x';
        });
      },

      _syncUIFromModel: function () {
        const obj = this.el.object3D;
        this.ui.scale.value = obj.scale.x;
        this.ui.rotX.value = obj.rotation.x;
        this.ui.rotY.value = obj.rotation.y;
        this.ui.rotZ.value = obj.rotation.z;
      },

      _setupAnimations: function (mesh) {
        const object3D = this.el.getObject3D('mesh');
        const clips = (object3D && object3D.animations && object3D.animations.length)
          ? object3D.animations
          : (mesh && mesh.animations && mesh.animations.length)
            ? mesh.animations
            : [];

        this.clips = clips;

        // UI反映
        this.ui.animSelect.innerHTML = '';
        if (!this.clips.length) {
          this.ui.animWrap.style.display = 'none';
          return;
        }

        this.ui.animWrap.style.display = 'block';
        this.mixer = new THREE.AnimationMixer(object3D || mesh);

        this.clips.forEach((clip, i) => {
          const opt = document.createElement('option');
          opt.value = i;
          opt.textContent = clip.name ? clip.name : `Animation ${i+1}`;
          this.ui.animSelect.appendChild(opt);
        });

        // 0番を選択して停止状態で準備
        this._playClipByIndex(0, false);
        this._setAnimStatus('停止（選択済み）');
      },

      _playClipByIndex: function (index, autoplay) {
        if (!this.mixer || !this.clips.length) return;
        const clip = this.clips[index];
        if (!clip) return;

        if (this.activeAction) this.activeAction.stop();

        this.activeAction = this.mixer.clipAction(clip);
        this.activeAction.reset();
        this.activeAction.loop = THREE.LoopRepeat;

        this.activeAction.play();
        if (autoplay) {
          this.isPlaying = true;
          this.activeAction.paused = false;
          this._setAnimStatus('再生中');
        } else {
          this.isPlaying = false;
          this.activeAction.paused = true;
        }

        this.mixer.setTime(0);
      },

      _setAnimStatus: function (t) {
        this.ui.animStatus.textContent = t;
      }
    });

    window.addEventListener('DOMContentLoaded', () => {
      const marker = document.getElementById('marker');
      const loader = document.getElementById('loader');
      marker.addEventListener('markerFound', () => { loader.textContent = 'モデル読み込み中…'; });
    });
  </script>
</head>

<body>
  <div id="loader" class="loader">Loading…（カメラ許可→マーカーを映してください）</div>

  <!-- UI 表示/非表示ボタン（右下固定） -->
  <button id="ui-toggle" class="ui-toggle" type="button">操作UIを隠す</button>

  <!-- UI（下部に移動） -->
  <div id="ui" class="ui">
    <div class="ui-head">
      <h2>操作UI <span class="badge">下部</span></h2>
      <span class="hint">UI外：ドラッグ回転／ピンチ拡大縮小</span>
    </div>

    <div class="grid">
      <div class="row">
        <label>サイズ</label>
        <input id="ui-scale" type="range" min="0.1" max="5.0" step="0.01" value="1.0" />
      </div>

      <div class="row">
        <label>自動回転</label>
        <input id="ui-autorotate" type="checkbox" />
      </div>

      <div class="row">
        <label>回転X</label>
        <input id="ui-rotx" type="range" min="-3.1416" max="3.1416" step="0.01" value="0" />
      </div>

      <div class="row">
        <label>回転Y</label>
        <input id="ui-roty" type="range" min="-3.1416" max="3.1416" step="0.01" value="0" />
      </div>

      <div class="row">
        <label>回転Z</label>
        <input id="ui-rotz" type="range" min="-3.1416" max="3.1416" step="0.01" value="0" />
      </div>

      <div class="btns" style="margin:6px 0 0;">
        <button id="ui-reset" type="button">リセット</button>
      </div>
    </div>

    <!-- アニメUI：アニメがある時だけ表示 -->
    <div id="ui-anim-wrap" style="margin-top:10px; display:none;">
      <div style="font-size:12px; margin:6px 0 6px; font-weight:700;">アニメーション</div>
      <select id="ui-anim-select"></select>

      <div class="btns" style="margin-top:8px;">
        <button id="ui-anim-play" type="button">再生</button>
        <button id="ui-anim-stop" type="button">停止</button>
        <span style="font-size:12px; opacity:.85; align-self:center;">
          状態：<span id="ui-anim-status">-</span>
        </span>
      </div>

      <div class="row" style="margin-top:8px;">
        <label>速度</label>
        <input id="ui-anim-speed" type="range" min="0.1" max="3.0" step="0.05" value="1.0" />
      </div>
      <div class="hint">速度：<span id="ui-anim-speed-val">1.00x</span></div>
    </div>
  </div>

  <!-- A-Frame Scene -->
  <a-scene
    embedded
    gesture-detector
    vr-mode-ui="enabled: false"
    renderer="logarithmicDepthBuffer: true; precision: medium;"
    arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;"
  >
    <a-assets>
      <a-asset-item id="model-asset" src="assets/model.glb"></a-asset-item>
    </a-assets>

    <a-marker id="marker" type="pattern" url="assets/marker.patt" emitevents="true">
      <a-entity light="type: ambient; intensity: 1.0"></a-entity>
      <a-entity light="type: directional; intensity: 0.8" position="1 2 1"></a-entity>

      <a-entity
        id="model"
        gltf-model="#model-asset"
        position="0 0 0"
        rotation="0 0 0"
        scale="1 1 1"
        gesture-handler
        model-ui-controller
      ></a-entity>
    </a-marker>

    <a-entity camera></a-entity>
  </a-scene>
</body>
</html>

